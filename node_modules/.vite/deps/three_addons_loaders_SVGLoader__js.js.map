{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/SVGLoader.js"],
  "sourcesContent": ["import {\r\n\tBox2,\r\n\tBufferGeometry,\r\n\tFileLoader,\r\n\tFloat32BufferAttribute,\r\n\tLoader,\r\n\tMatrix3,\r\n\tPath,\r\n\tShape,\r\n\tShapePath,\r\n\tShapeUtils,\r\n\tSRGBColorSpace,\r\n\tVector2,\r\n\tVector3\r\n} from 'three';\r\n\r\nconst COLOR_SPACE_SVG = SRGBColorSpace;\r\n\r\nclass SVGLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\t// Default dots per inch\r\n\t\tthis.defaultDPI = 90;\r\n\r\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\r\n\t\tthis.defaultUnit = 'px';\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new FileLoader( scope.manager );\r\n\t\tloader.setPath( scope.path );\r\n\t\tloader.setRequestHeader( scope.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( text ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tfunction parseNode( node, style ) {\r\n\r\n\t\t\tif ( node.nodeType !== 1 ) return;\r\n\r\n\t\t\tconst transform = getNodeTransform( node );\r\n\r\n\t\t\tlet isDefsNode = false;\r\n\r\n\t\t\tlet path = null;\r\n\r\n\t\t\tswitch ( node.nodeName ) {\r\n\r\n\t\t\t\tcase 'svg':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'style':\r\n\t\t\t\t\tparseCSSStylesheet( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'g':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'path':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rect':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseRectNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polygon':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolygonNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polyline':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolylineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'circle':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseCircleNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ellipse':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseEllipseNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'line':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseLineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'defs':\r\n\t\t\t\t\tisDefsNode = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'use':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\r\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\r\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\r\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\r\n\t\t\t\t\tif ( usedNode ) {\r\n\r\n\t\t\t\t\t\tparseNode( usedNode, style );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// console.log( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( path ) {\r\n\r\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\r\n\r\n\t\t\t\t\tpath.color.setStyle( style.fill, COLOR_SPACE_SVG );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransformPath( path, currentTransform );\r\n\r\n\t\t\t\tpaths.push( path );\r\n\r\n\t\t\t\tpath.userData = { node: node, style: style };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst childNodes = node.childNodes;\r\n\r\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tconst node = childNodes[ i ];\r\n\r\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\r\n\r\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\r\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\r\n\t\t\t\t\t// <style/> there.\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparseNode( node, style );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( transform ) {\r\n\r\n\t\t\t\ttransformStack.pop();\r\n\r\n\t\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePathNode( node ) {\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\tconst point = new Vector2();\r\n\t\t\tconst control = new Vector2();\r\n\r\n\t\t\tconst firstPoint = new Vector2();\r\n\t\t\tlet isFirstPoint = true;\r\n\t\t\tlet doSetFirstPoint = false;\r\n\r\n\t\t\tconst d = node.getAttribute( 'd' );\r\n\r\n\t\t\tif ( d === '' || d === 'none' ) return null;\r\n\r\n\t\t\t// console.log( d );\r\n\r\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\r\n\r\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst command = commands[ i ];\r\n\r\n\t\t\t\tconst type = command.charAt( 0 );\r\n\t\t\t\tconst data = command.slice( 1 ).trim();\r\n\r\n\t\t\t\tif ( isFirstPoint === true ) {\r\n\r\n\t\t\t\t\tdoSetFirstPoint = true;\r\n\t\t\t\t\tisFirstPoint = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet numbers;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'L':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'C':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Q':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if start point == end point\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\r\n\r\n\t\t\t\t\t\t\tconst start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if no displacement\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\r\n\r\n\t\t\t\t\t\t\tconst start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\t// Reset point to beginning of Path\r\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\r\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\r\n\t\t\t\t\t\t\tisFirstPoint = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( command );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\r\n\r\n\t\t\t\tdoSetFirstPoint = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCSSStylesheet( node ) {\r\n\r\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\r\n\r\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\r\n\r\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\r\n\r\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\r\n\r\n\t\t\t\tconst selectorList = stylesheet.selectorText\r\n\t\t\t\t\t.split( /,/gm )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\r\n\r\n\t\t\t\t\t// Remove empty rules\r\n\t\t\t\t\tconst definitions = Object.fromEntries(\r\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\r\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\r\n\t\t\t\t\t\tdefinitions\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\r\n\t\t * From\r\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n\t\t * To\r\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\r\n\t\t */\r\n\r\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\r\n\r\n\t\t\tif ( rx == 0 || ry == 0 ) {\r\n\r\n\t\t\t\t// draw a line if either of the radii == 0\r\n\t\t\t\tpath.lineTo( end.x, end.y );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\r\n\r\n\t\t\t// Ensure radii are positive\r\n\t\t\trx = Math.abs( rx );\r\n\t\t\try = Math.abs( ry );\r\n\r\n\t\t\t// Compute (x1', y1')\r\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\r\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\r\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\r\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\r\n\r\n\t\t\t// Compute (cx', cy')\r\n\t\t\tlet rxs = rx * rx;\r\n\t\t\tlet rys = ry * ry;\r\n\t\t\tconst x1ps = x1p * x1p;\r\n\t\t\tconst y1ps = y1p * y1p;\r\n\r\n\t\t\t// Ensure radii are large enough\r\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\r\n\r\n\t\t\tif ( cr > 1 ) {\r\n\r\n\t\t\t\t// scale up rx,ry equally so cr == 1\r\n\t\t\t\tconst s = Math.sqrt( cr );\r\n\t\t\t\trx = s * rx;\r\n\t\t\t\try = s * ry;\r\n\t\t\t\trxs = rx * rx;\r\n\t\t\t\trys = ry * ry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\r\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\r\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\r\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\r\n\t\t\tconst cxp = q * rx * y1p / ry;\r\n\t\t\tconst cyp = - q * ry * x1p / rx;\r\n\r\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\r\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\r\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\r\n\r\n\t\t\t// Step 4: Compute θ1 and Δθ\r\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\r\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\r\n\r\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\r\n\r\n\t\t}\r\n\r\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\r\n\r\n\t\t\tconst dot = ux * vx + uy * vy;\r\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\r\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\r\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\r\n\t\t\treturn ang;\r\n\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\r\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\r\n\t\t*/\r\n\t\tfunction parseRectNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\r\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\r\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\r\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\r\n\r\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\r\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\r\n\t\t\tconst bci = 1 - 0.551915024494;\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\t// top left\r\n\t\t\tpath.moveTo( x + rx, y );\r\n\r\n\t\t\t// top right\r\n\t\t\tpath.lineTo( x + w - rx, y );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + w - rx * bci,\r\n\t\t\t\t\ty,\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + ry * bci,\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + ry\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom right\r\n\t\t\tpath.lineTo( x + w, y + h - ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + h - ry * bci,\r\n\t\t\t\t\tx + w - rx * bci,\r\n\t\t\t\t\ty + h,\r\n\t\t\t\t\tx + w - rx,\r\n\t\t\t\t\ty + h\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom left\r\n\t\t\tpath.lineTo( x + rx, y + h );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + rx * bci,\r\n\t\t\t\t\ty + h,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty + h - ry * bci,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty + h - ry\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// back to top left\r\n\t\t\tpath.lineTo( x, y + ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolygonNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tconst x = parseFloatWithUnits( a );\r\n\t\t\t\tconst y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolylineNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tconst x = parseFloatWithUnits( a );\r\n\t\t\t\tconst y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCircleNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\r\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\r\n\r\n\t\t\tconst subpath = new Path();\r\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEllipseNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\r\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\r\n\r\n\t\t\tconst subpath = new Path();\r\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLineNode( node ) {\r\n\r\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\r\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\r\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\r\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\t\t\tpath.moveTo( x1, y1 );\r\n\t\t\tpath.lineTo( x2, y2 );\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction parseStyle( node, style ) {\r\n\r\n\t\t\tstyle = Object.assign( {}, style ); // clone style\r\n\r\n\t\t\tlet stylesheetStyles = {};\r\n\r\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\r\n\r\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\r\n\t\t\t\t\t.split( /\\s/ )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\r\n\r\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\r\n\r\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\r\n\r\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\r\n\r\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\r\n\r\n\t\t\t\t\treturn v;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\r\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\r\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction clamp( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction positive( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddStyle( 'fill', 'fill' );\r\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\r\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\r\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\r\n\t\t\taddStyle( 'stroke', 'stroke' );\r\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\r\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\r\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\r\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\r\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\r\n\t\t\taddStyle( 'visibility', 'visibility' );\r\n\r\n\t\t\treturn style;\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\r\n\r\n\t\tfunction getReflection( a, b ) {\r\n\r\n\t\t\treturn a - ( b - a );\r\n\r\n\t\t}\r\n\r\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\r\n\r\n\t\tfunction parseFloats( input, flags, stride ) {\r\n\r\n\t\t\tif ( typeof input !== 'string' ) {\r\n\r\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Character groups\r\n\t\t\tconst RE = {\r\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\r\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\r\n\t\t\t\tDIGIT: /[\\d]/,\r\n\t\t\t\tSIGN: /[-+]/,\r\n\t\t\t\tPOINT: /\\./,\r\n\t\t\t\tCOMMA: /,/,\r\n\t\t\t\tEXP: /e/i,\r\n\t\t\t\tFLAGS: /[01]/\r\n\t\t\t};\r\n\r\n\t\t\t// States\r\n\t\t\tconst SEP = 0;\r\n\t\t\tconst INT = 1;\r\n\t\t\tconst FLOAT = 2;\r\n\t\t\tconst EXP = 3;\r\n\r\n\t\t\tlet state = SEP;\r\n\t\t\tlet seenComma = true;\r\n\t\t\tlet number = '', exponent = '';\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\r\n\r\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\r\n\t\t\t\terror.partial = partial;\r\n\t\t\t\tthrow error;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction newNumber() {\r\n\r\n\t\t\t\tif ( number !== '' ) {\r\n\r\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\r\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnumber = '';\r\n\t\t\t\texponent = '';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet current;\r\n\t\t\tconst length = input.length;\r\n\r\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tcurrent = input[ i ];\r\n\r\n\t\t\t\t// check for flags\r\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\r\n\r\n\t\t\t\t\tstate = INT;\r\n\t\t\t\t\tnumber = current;\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse until next number\r\n\t\t\t\tif ( state === SEP ) {\r\n\r\n\t\t\t\t\t// eat whitespace\r\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// start new number\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = INT;\r\n\t\t\t\t\t\tnumber = current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\t\tnumber = current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\r\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\r\n\r\n\t\t\t\t\t\tif ( seenComma ) {\r\n\r\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tseenComma = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse integer part\r\n\t\t\t\tif ( state === INT ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = EXP;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\r\n\t\t\t\t\tif ( RE.SIGN.test( current )\r\n\t\t\t\t\t\t\t&& number.length === 1\r\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\r\n\r\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse decimal part\r\n\t\t\t\tif ( state === FLOAT ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = EXP;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\r\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\r\n\r\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse exponent part\r\n\t\t\t\tif ( state === EXP ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\texponent += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\t\tif ( exponent === '' ) {\r\n\r\n\t\t\t\t\t\t\texponent += current;\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\r\n\r\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// end of number\r\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = SEP;\r\n\t\t\t\t\tseenComma = false;\r\n\r\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = SEP;\r\n\t\t\t\t\tseenComma = true;\r\n\r\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = INT;\r\n\t\t\t\t\tnumber = current;\r\n\r\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\tnumber = current;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add the last number found (if any)\r\n\t\t\tnewNumber();\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// Units\r\n\r\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\r\n\r\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\r\n\t\tconst unitConversion = {\r\n\r\n\t\t\t'mm': {\r\n\t\t\t\t'mm': 1,\r\n\t\t\t\t'cm': 0.1,\r\n\t\t\t\t'in': 1 / 25.4,\r\n\t\t\t\t'pt': 72 / 25.4,\r\n\t\t\t\t'pc': 6 / 25.4,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'cm': {\r\n\t\t\t\t'mm': 10,\r\n\t\t\t\t'cm': 1,\r\n\t\t\t\t'in': 1 / 2.54,\r\n\t\t\t\t'pt': 72 / 2.54,\r\n\t\t\t\t'pc': 6 / 2.54,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'in': {\r\n\t\t\t\t'mm': 25.4,\r\n\t\t\t\t'cm': 2.54,\r\n\t\t\t\t'in': 1,\r\n\t\t\t\t'pt': 72,\r\n\t\t\t\t'pc': 6,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pt': {\r\n\t\t\t\t'mm': 25.4 / 72,\r\n\t\t\t\t'cm': 2.54 / 72,\r\n\t\t\t\t'in': 1 / 72,\r\n\t\t\t\t'pt': 1,\r\n\t\t\t\t'pc': 6 / 72,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pc': {\r\n\t\t\t\t'mm': 25.4 / 6,\r\n\t\t\t\t'cm': 2.54 / 6,\r\n\t\t\t\t'in': 1 / 6,\r\n\t\t\t\t'pt': 72 / 6,\r\n\t\t\t\t'pc': 1,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'px': {\r\n\t\t\t\t'px': 1\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseFloatWithUnits( string ) {\r\n\r\n\t\t\tlet theUnit = 'px';\r\n\r\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\r\n\r\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\r\n\r\n\t\t\t\t\tconst u = units[ i ];\r\n\r\n\t\t\t\t\tif ( string.endsWith( u ) ) {\r\n\r\n\t\t\t\t\t\ttheUnit = u;\r\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet scale = undefined;\r\n\r\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\r\n\r\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\r\n\r\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\r\n\r\n\t\t\t\tif ( scale < 0 ) {\r\n\r\n\t\t\t\t\t// Conversion scale to pixels\r\n\r\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn scale * parseFloat( string );\r\n\r\n\t\t}\r\n\r\n\t\t// Transforms\r\n\r\n\t\tfunction getNodeTransform( node ) {\r\n\r\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst transform = parseNodeTransform( node );\r\n\r\n\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentTransform.copy( transform );\r\n\t\t\ttransformStack.push( transform );\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNodeTransform( node ) {\r\n\r\n\t\t\tconst transform = new Matrix3();\r\n\t\t\tconst currentTransform = tempTransform0;\r\n\r\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\r\n\r\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\r\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\r\n\r\n\t\t\t\ttransform.translate( tx, ty );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\r\n\r\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\r\n\r\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\r\n\r\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\r\n\r\n\t\t\t\t\tif ( transformText === '' ) continue;\r\n\r\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\r\n\t\t\t\t\tconst closeParPos = transformText.length;\r\n\r\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\r\n\r\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\r\n\r\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\r\n\r\n\t\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t\t\tswitch ( transformType ) {\r\n\r\n\t\t\t\t\t\t\tcase 'translate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tlet ty = 0;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'rotate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tlet angle = 0;\r\n\t\t\t\t\t\t\t\t\tlet cx = 0;\r\n\t\t\t\t\t\t\t\t\tlet cy = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t// Angle\r\n\t\t\t\t\t\t\t\t\tangle = array[ 0 ] * Math.PI / 180;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Center x, y\r\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\r\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\r\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( - cx, - cy );\r\n\t\t\t\t\t\t\t\t\ttempTransform2.makeRotation( angle );\r\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\r\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( cx, cy );\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'scale':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewX':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewY':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\r\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'matrix':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\r\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttransform.premultiply( currentTransform );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction transformPath( path, m ) {\r\n\r\n\t\t\tfunction transfVec2( v2 ) {\r\n\r\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\r\n\r\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transfEllipseGeneric( curve ) {\r\n\r\n\t\t\t\t// For math description see:\r\n\t\t\t\t// https://math.stackexchange.com/questions/4544164\r\n\r\n\t\t\t\tconst a = curve.xRadius;\r\n\t\t\t\tconst b = curve.yRadius;\r\n\r\n\t\t\t\tconst cosTheta = Math.cos( curve.aRotation );\r\n\t\t\t\tconst sinTheta = Math.sin( curve.aRotation );\r\n\r\n\t\t\t\tconst v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );\r\n\t\t\t\tconst v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 );\r\n\r\n\t\t\t\tconst f1 = v1.applyMatrix3( m );\r\n\t\t\t\tconst f2 = v2.applyMatrix3( m );\r\n\r\n\t\t\t\tconst mF = tempTransform0.set(\r\n\t\t\t\t\tf1.x, f2.x, 0,\r\n\t\t\t\t\tf1.y, f2.y, 0,\r\n\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst mFInv = tempTransform1.copy( mF ).invert();\r\n\t\t\t\tconst mFInvT = tempTransform2.copy( mFInv ).transpose();\r\n\t\t\t\tconst mQ = mFInvT.multiply( mFInv );\r\n\t\t\t\tconst mQe = mQ.elements;\r\n\r\n\t\t\t\tconst ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );\r\n\t\t\t\tconst rt1sqrt = Math.sqrt( ed.rt1 );\r\n\t\t\t\tconst rt2sqrt = Math.sqrt( ed.rt2 );\r\n\r\n\t\t\t\tcurve.xRadius = 1 / rt1sqrt;\r\n\t\t\t\tcurve.yRadius = 1 / rt2sqrt;\r\n\t\t\t\tcurve.aRotation = Math.atan2( ed.sn, ed.cs );\r\n\r\n\t\t\t\tconst isFullEllipse =\r\n\t\t\t\t\t( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;\r\n\r\n\t\t\t\t// Do not touch angles of a full ellipse because after transformation they\r\n\t\t\t\t// would converge to a sinle value effectively removing the whole curve\r\n\r\n\t\t\t\tif ( ! isFullEllipse ) {\r\n\r\n\t\t\t\t\tconst mDsqrt = tempTransform1.set(\r\n\t\t\t\t\t\trt1sqrt, 0, 0,\r\n\t\t\t\t\t\t0, rt2sqrt, 0,\r\n\t\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tconst mRT = tempTransform2.set(\r\n\t\t\t\t\t\ted.cs, ed.sn, 0,\r\n\t\t\t\t\t\t- ed.sn, ed.cs, 0,\r\n\t\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tconst mDRF = mDsqrt.multiply( mRT ).multiply( mF );\r\n\r\n\t\t\t\t\tconst transformAngle = phi => {\r\n\r\n\t\t\t\t\t\tconst { x: cosR, y: sinR } =\r\n\t\t\t\t\t\t\tnew Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );\r\n\r\n\t\t\t\t\t\treturn Math.atan2( sinR, cosR );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tcurve.aStartAngle = transformAngle( curve.aStartAngle );\r\n\t\t\t\t\tcurve.aEndAngle = transformAngle( curve.aEndAngle );\r\n\r\n\t\t\t\t\tif ( isTransformFlipped( m ) ) {\r\n\r\n\t\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transfEllipseNoSkew( curve ) {\r\n\r\n\t\t\t\t// Faster shortcut if no skew is applied\r\n\t\t\t\t// (e.g, a euclidean transform of a group containing the ellipse)\r\n\r\n\t\t\t\tconst sx = getTransformScaleX( m );\r\n\t\t\t\tconst sy = getTransformScaleY( m );\r\n\r\n\t\t\t\tcurve.xRadius *= sx;\r\n\t\t\t\tcurve.yRadius *= sy;\r\n\r\n\t\t\t\t// Extract rotation angle from the matrix of form:\r\n\t\t\t\t//\r\n\t\t\t\t//  | cosθ sx   -sinθ sy |\r\n\t\t\t\t//  | sinθ sx    cosθ sy |\r\n\t\t\t\t//\r\n\t\t\t\t// Remembering that tanθ = sinθ / cosθ; and that\r\n\t\t\t\t// `sx`, `sy`, or both might be zero.\r\n\t\t\t\tconst theta =\r\n\t\t\t\t\tsx > Number.EPSILON\r\n\t\t\t\t\t\t? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )\r\n\t\t\t\t\t\t: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );\r\n\r\n\t\t\t\tcurve.aRotation += theta;\r\n\r\n\t\t\t\tif ( isTransformFlipped( m ) ) {\r\n\r\n\t\t\t\t\tcurve.aStartAngle *= - 1;\r\n\t\t\t\t\tcurve.aEndAngle *= - 1;\r\n\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst subPaths = path.subPaths;\r\n\r\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\r\n\r\n\t\t\t\tconst subPath = subPaths[ i ];\r\n\t\t\t\tconst curves = subPath.curves;\r\n\r\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\r\n\r\n\t\t\t\t\tconst curve = curves[ j ];\r\n\r\n\t\t\t\t\tif ( curve.isLineCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\t\t\t\t\t\ttransfVec2( curve.v3 );\r\n\r\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\r\n\r\n\t\t\t\t\t\t// Transform ellipse center point\r\n\r\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\r\n\t\t\t\t\t\ttransfVec2( tempV2 );\r\n\t\t\t\t\t\tcurve.aX = tempV2.x;\r\n\t\t\t\t\t\tcurve.aY = tempV2.y;\r\n\r\n\t\t\t\t\t\t// Transform ellipse shape parameters\r\n\r\n\t\t\t\t\t\tif ( isTransformSkewed( m ) ) {\r\n\r\n\t\t\t\t\t\t\ttransfEllipseGeneric( curve );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttransfEllipseNoSkew( curve );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformFlipped( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformSkewed( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\tconst basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];\r\n\r\n\t\t\t// Shortcut for trivial rotations and transformations\r\n\t\t\tif ( basisDot === 0 ) return false;\r\n\r\n\t\t\tconst sx = getTransformScaleX( m );\r\n\t\t\tconst sy = getTransformScaleY( m );\r\n\r\n\t\t\treturn Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleX( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleY( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\r\n\r\n\t\t}\r\n\r\n\t\t// Calculates the eigensystem of a real symmetric 2x2 matrix\r\n\t\t//    [ A  B ]\r\n\t\t//    [ B  C ]\r\n\t\t// in the form\r\n\t\t//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\r\n\t\t//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\r\n\t\t// where rt1 >= rt2.\r\n\t\t//\r\n\t\t// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\r\n\t\t// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\r\n\t\tfunction eigenDecomposition( A, B, C ) {\r\n\r\n\t\t\tlet rt1, rt2, cs, sn, t;\r\n\t\t\tconst sm = A + C;\r\n\t\t\tconst df = A - C;\r\n\t\t\tconst rt = Math.sqrt( df * df + 4 * B * B );\r\n\r\n\t\t\tif ( sm > 0 ) {\r\n\r\n\t\t\t\trt1 = 0.5 * ( sm + rt );\r\n\t\t\t\tt = 1 / rt1;\r\n\t\t\t\trt2 = A * t * C - B * t * B;\r\n\r\n\t\t\t} else if ( sm < 0 ) {\r\n\r\n\t\t\t\trt2 = 0.5 * ( sm - rt );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// This case needs to be treated separately to avoid div by 0\r\n\r\n\t\t\t\trt1 = 0.5 * rt;\r\n\t\t\t\trt2 = - 0.5 * rt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Calculate eigenvectors\r\n\r\n\t\t\tif ( df > 0 ) {\r\n\r\n\t\t\t\tcs = df + rt;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcs = df - rt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( Math.abs( cs ) > 2 * Math.abs( B ) ) {\r\n\r\n\t\t\t\tt = - 2 * B / cs;\r\n\t\t\t\tsn = 1 / Math.sqrt( 1 + t * t );\r\n\t\t\t\tcs = t * sn;\r\n\r\n\t\t\t} else if ( Math.abs( B ) === 0 ) {\r\n\r\n\t\t\t\tcs = 1;\r\n\t\t\t\tsn = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tt = - 0.5 * cs / B;\r\n\t\t\t\tcs = 1 / Math.sqrt( 1 + t * t );\r\n\t\t\t\tsn = t * cs;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( df > 0 ) {\r\n\r\n\t\t\t\tt = cs;\r\n\t\t\t\tcs = - sn;\r\n\t\t\t\tsn = t;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { rt1, rt2, cs, sn };\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst paths = [];\r\n\t\tconst stylesheets = {};\r\n\r\n\t\tconst transformStack = [];\r\n\r\n\t\tconst tempTransform0 = new Matrix3();\r\n\t\tconst tempTransform1 = new Matrix3();\r\n\t\tconst tempTransform2 = new Matrix3();\r\n\t\tconst tempTransform3 = new Matrix3();\r\n\t\tconst tempV2 = new Vector2();\r\n\t\tconst tempV3 = new Vector3();\r\n\r\n\t\tconst currentTransform = new Matrix3();\r\n\r\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\r\n\r\n\t\tparseNode( xml.documentElement, {\r\n\t\t\tfill: '#000',\r\n\t\t\tfillOpacity: 1,\r\n\t\t\tstrokeOpacity: 1,\r\n\t\t\tstrokeWidth: 1,\r\n\t\t\tstrokeLineJoin: 'miter',\r\n\t\t\tstrokeLineCap: 'butt',\r\n\t\t\tstrokeMiterLimit: 4\r\n\t\t} );\r\n\r\n\t\tconst data = { paths: paths, xml: xml.documentElement };\r\n\r\n\t\t// console.log( paths );\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tstatic createShapes( shapePath ) {\r\n\r\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\r\n\t\t// Returns Shape object\r\n\r\n\t\tconst BIGNUMBER = 999999999;\r\n\r\n\t\tconst IntersectionLocationType = {\r\n\t\t\tORIGIN: 0,\r\n\t\t\tDESTINATION: 1,\r\n\t\t\tBETWEEN: 2,\r\n\t\t\tLEFT: 3,\r\n\t\t\tRIGHT: 4,\r\n\t\t\tBEHIND: 5,\r\n\t\t\tBEYOND: 6\r\n\t\t};\r\n\r\n\t\tconst classifyResult = {\r\n\t\t\tloc: IntersectionLocationType.ORIGIN,\r\n\t\t\tt: 0\r\n\t\t};\r\n\r\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\r\n\r\n\t\t\tconst x1 = a0.x;\r\n\t\t\tconst x2 = a1.x;\r\n\t\t\tconst x3 = b0.x;\r\n\t\t\tconst x4 = b1.x;\r\n\t\t\tconst y1 = a0.y;\r\n\t\t\tconst y2 = a1.y;\r\n\t\t\tconst y3 = b0.y;\r\n\t\t\tconst y4 = b1.y;\r\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\r\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\r\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\r\n\t\t\tconst t1 = nom1 / denom;\r\n\t\t\tconst t2 = nom2 / denom;\r\n\r\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\r\n\r\n\t\t\t\t//1. lines are parallel or edges don't intersect\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\r\n\r\n\t\t\t\t//2. lines are colinear\r\n\r\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\r\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\r\n\r\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\r\n\t\t\t\t\t//find position of this endpoints relatively to edge1\r\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\r\n\r\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\r\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\r\n\r\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\r\n\r\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\r\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\r\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//3. edges intersect\r\n\r\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\r\n\r\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\r\n\r\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\r\n\r\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\r\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\r\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\r\n\t\t\t\treturn { x: x, y: y, t: t1 };\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\r\n\r\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\r\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\r\n\t\t\tconst bx = p.x - edgeStart.x;\r\n\t\t\tconst by = p.y - edgeStart.y;\r\n\t\t\tconst sa = ax * by - bx * ay;\r\n\r\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\r\n\t\t\t\tclassifyResult.t = 0;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\r\n\t\t\t\tclassifyResult.t = 1;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sa < - Number.EPSILON ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sa > Number.EPSILON ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\r\n\t\t\t\treturn;\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet t;\r\n\r\n\t\t\tif ( ax !== 0 ) {\r\n\r\n\t\t\t\tt = bx / ax;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tt = by / ay;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\r\n\t\t\tclassifyResult.t = t;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getIntersections( path1, path2 ) {\r\n\r\n\t\t\tconst intersectionsRaw = [];\r\n\t\t\tconst intersections = [];\r\n\r\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\r\n\r\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\r\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\r\n\r\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\r\n\r\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\r\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\r\n\r\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\r\n\r\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\r\n\r\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\r\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn intersections;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\r\n\r\n\t\t\tconst center = new Vector2();\r\n\t\t\tboundingBox.getCenter( center );\r\n\r\n\t\t\tconst allIntersections = [];\r\n\r\n\t\t\tpaths.forEach( path => {\r\n\r\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\r\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\r\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\r\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\r\n\r\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\r\n\r\n\t\t\t\t\tintersections.forEach( p => {\r\n\r\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\r\n\r\n\t\t\t\treturn i1.point.x - i2.point.x;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn allIntersections;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\r\n\r\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\r\n\r\n\t\t\t\t_fillRule = 'nonzero';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst centerBoundingBox = new Vector2();\r\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\r\n\r\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\r\n\r\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\r\n\r\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\r\n\r\n\t\t\t\treturn i1.point.x - i2.point.x;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst baseIntersections = [];\r\n\t\t\tconst otherIntersections = [];\r\n\r\n\t\t\tscanlineIntersections.forEach( i => {\r\n\r\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\r\n\r\n\t\t\t\t\tbaseIntersections.push( i );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\totherIntersections.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\r\n\r\n\t\t\t// build up the path hierarchy\r\n\t\t\tconst stack = [];\r\n\t\t\tlet i = 0;\r\n\r\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\r\n\r\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\r\n\r\n\t\t\t\t\tstack.pop();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstack.push( simplePath.identifier );\r\n\r\n\t\t\tif ( _fillRule === 'evenodd' ) {\r\n\r\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\r\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\r\n\r\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\r\n\r\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\r\n\r\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\r\n\t\t\t\tlet isHole = true;\r\n\t\t\t\tlet isHoleFor = null;\r\n\t\t\t\tlet lastCWValue = null;\r\n\r\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\r\n\r\n\t\t\t\t\tconst identifier = stack[ i ];\r\n\t\t\t\t\tif ( isHole ) {\r\n\r\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\r\n\t\t\t\t\t\tisHole = false;\r\n\t\t\t\t\t\tisHoleFor = identifier;\r\n\r\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\r\n\r\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\r\n\t\t\t\t\t\tisHole = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check for self intersecting paths\r\n\t\t// TODO\r\n\r\n\t\t// check intersecting paths\r\n\t\t// TODO\r\n\r\n\t\t// prepare paths for hole detection\r\n\t\tlet scanlineMinX = BIGNUMBER;\r\n\t\tlet scanlineMaxX = - BIGNUMBER;\r\n\r\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\r\n\r\n\t\t\tconst points = p.getPoints();\r\n\t\t\tlet maxY = - BIGNUMBER;\r\n\t\t\tlet minY = BIGNUMBER;\r\n\t\t\tlet maxX = - BIGNUMBER;\r\n\t\t\tlet minX = BIGNUMBER;\r\n\r\n\t      \t//points.forEach(p => p.y *= -1);\r\n\r\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\r\n\r\n\t\t\t\tconst p = points[ i ];\r\n\r\n\t\t\t\tif ( p.y > maxY ) {\r\n\r\n\t\t\t\t\tmaxY = p.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.y < minY ) {\r\n\r\n\t\t\t\t\tminY = p.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.x > maxX ) {\r\n\r\n\t\t\t\t\tmaxX = p.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.x < minX ) {\r\n\r\n\t\t\t\t\tminX = p.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\t\t\tif ( scanlineMaxX <= maxX ) {\r\n\r\n\t\t\t\tscanlineMaxX = maxX + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scanlineMinX >= minX ) {\r\n\r\n\t\t\t\tscanlineMinX = minX - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\r\n\r\n\t\t} );\r\n\r\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\r\n\r\n\t\tfor ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {\r\n\r\n\t\t\tsimplePaths[ identifier ].identifier = identifier;\r\n\r\n\t\t}\r\n\r\n\t\t// check if path is solid or a hole\r\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );\r\n\r\n\r\n\t\tconst shapesToReturn = [];\r\n\t\tsimplePaths.forEach( p => {\r\n\r\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\r\n\r\n\t\t\tif ( ! amIAHole.isHole ) {\r\n\r\n\t\t\t\tconst shape = new Shape();\r\n\t\t\t\tshape.curves = p.curves;\r\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\r\n\t\t\t\tholes.forEach( h => {\r\n\r\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\r\n\t\t\t\t\tconst path = new Path();\r\n\t\t\t\t\tpath.curves = hole.curves;\r\n\t\t\t\t\tshape.holes.push( path );\r\n\r\n\t\t\t\t} );\r\n\t\t\t\tshapesToReturn.push( shape );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn shapesToReturn;\r\n\r\n\t}\r\n\r\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\r\n\r\n\t\t// Param width: Stroke width\r\n\t\t// Param color: As returned by THREE.Color.getStyle()\r\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\r\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\r\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\r\n\t\t// Returns style object\r\n\r\n\t\twidth = width !== undefined ? width : 1;\r\n\t\tcolor = color !== undefined ? color : '#000';\r\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\r\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\r\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\r\n\r\n\t\treturn {\r\n\t\t\tstrokeColor: color,\r\n\t\t\tstrokeWidth: width,\r\n\t\t\tstrokeLineJoin: lineJoin,\r\n\t\t\tstrokeLineCap: lineCap,\r\n\t\t\tstrokeMiterLimit: miterLimit\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\r\n\r\n\t\t// Generates a stroke with some width around the given path.\r\n\t\t// The path can be open or closed (last point equals to first point)\r\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\r\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\r\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\r\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\r\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\r\n\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = new BufferGeometry();\r\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\r\n\r\n\t\t// This function can be called to update existing arrays or buffers.\r\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\r\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\r\n\t\t// Returns number of written vertices / normals / uvs pairs\r\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\r\n\t\t// 'normals' and 'uvs' buffers are optional\r\n\r\n\t\tconst tempV2_1 = new Vector2();\r\n\t\tconst tempV2_2 = new Vector2();\r\n\t\tconst tempV2_3 = new Vector2();\r\n\t\tconst tempV2_4 = new Vector2();\r\n\t\tconst tempV2_5 = new Vector2();\r\n\t\tconst tempV2_6 = new Vector2();\r\n\t\tconst tempV2_7 = new Vector2();\r\n\t\tconst lastPointL = new Vector2();\r\n\t\tconst lastPointR = new Vector2();\r\n\t\tconst point0L = new Vector2();\r\n\t\tconst point0R = new Vector2();\r\n\t\tconst currentPointL = new Vector2();\r\n\t\tconst currentPointR = new Vector2();\r\n\t\tconst nextPointL = new Vector2();\r\n\t\tconst nextPointR = new Vector2();\r\n\t\tconst innerPoint = new Vector2();\r\n\t\tconst outerPoint = new Vector2();\r\n\r\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\r\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\r\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\r\n\r\n\t\t// First ensure there are no duplicated points\r\n\t\tpoints = removeDuplicatedPoints( points );\r\n\r\n\t\tconst numPoints = points.length;\r\n\r\n\t\tif ( numPoints < 2 ) return 0;\r\n\r\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\r\n\r\n\t\tlet currentPoint;\r\n\t\tlet previousPoint = points[ 0 ];\r\n\t\tlet nextPoint;\r\n\r\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\r\n\r\n\t\tconst deltaU = 1 / ( numPoints - 1 );\r\n\t\tlet u0 = 0, u1;\r\n\r\n\t\tlet innerSideModified;\r\n\t\tlet joinIsOnLeftSide;\r\n\t\tlet isMiter;\r\n\t\tlet initialJoinIsOnLeftSide = false;\r\n\r\n\t\tlet numVertices = 0;\r\n\t\tlet currentCoordinate = vertexOffset * 3;\r\n\t\tlet currentCoordinateUV = vertexOffset * 2;\r\n\r\n\t\t// Get initial left and right stroke points\r\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\r\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\r\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\r\n\t\tpoint0L.copy( lastPointL );\r\n\t\tpoint0R.copy( lastPointR );\r\n\r\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\r\n\r\n\t\t\tcurrentPoint = points[ iPoint ];\r\n\r\n\t\t\t// Get next point\r\n\t\t\tif ( iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\tif ( isClosed ) {\r\n\r\n\t\t\t\t\t// Skip duplicated initial point\r\n\t\t\t\t\tnextPoint = points[ 1 ];\r\n\r\n\t\t\t\t} else nextPoint = undefined;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Normal of previous segment in tempV2_1\r\n\t\t\tconst normal1 = tempV2_1;\r\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\r\n\r\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\r\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\tu1 = u0 + deltaU;\r\n\r\n\t\t\tinnerSideModified = false;\r\n\r\n\t\t\tif ( nextPoint !== undefined ) {\r\n\r\n\t\t\t\t// Normal of next segment in tempV2_2\r\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\r\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\t\tjoinIsOnLeftSide = true;\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\r\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\r\n\r\n\t\t\t\t\tjoinIsOnLeftSide = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\r\n\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\r\n\t\t\t\ttempV2_3.normalize();\r\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\r\n\r\n\t\t\t\t// If path is straight, don't create join\r\n\t\t\t\tif ( dot > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// Compute inner and outer segment intersections\r\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\r\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\r\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\r\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\r\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\r\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\r\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\r\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\r\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\r\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\r\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\r\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\r\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\r\n\r\n\t\t\t\t\t\tinnerSideModified = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\r\n\t\t\t\t\tinnerPoint.add( currentPoint );\r\n\r\n\t\t\t\t\tisMiter = false;\r\n\r\n\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\r\n\r\n\t\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\r\n\r\n\t\t\t\t\t\tcase 'bevel':\r\n\r\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t// Join triangles\r\n\r\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'miter':\r\n\t\t\t\t\t\tcase 'miter-clip':\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\r\n\r\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\r\n\r\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// Miter join segment triangles\r\n\r\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tisMiter = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\r\n\r\n\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\r\n\r\n\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\t// Start line endcap\r\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Increment loop variables\r\n\r\n\t\t\tu0 = u1;\r\n\r\n\t\t\tpreviousPoint = currentPoint;\r\n\r\n\t\t\tlastPointL.copy( nextPointL );\r\n\t\t\tlastPointR.copy( nextPointR );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! isClosed ) {\r\n\r\n\t\t\t// Ending line endcap\r\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\r\n\r\n\t\t} else if ( innerSideModified && vertices ) {\r\n\r\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\r\n\r\n\t\t\tlet lastOuter = outerPoint;\r\n\t\t\tlet lastInner = innerPoint;\r\n\r\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tlastOuter = innerPoint;\r\n\t\t\t\tlastInner = outerPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn numVertices;\r\n\r\n\t\t// -- End of algorithm\r\n\r\n\t\t// -- Functions\r\n\r\n\t\tfunction getNormal( p1, p2, result ) {\r\n\r\n\t\t\tresult.subVectors( p2, p1 );\r\n\t\t\treturn result.set( - result.y, result.x ).normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( position, u, v ) {\r\n\r\n\t\t\tif ( vertices ) {\r\n\r\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\r\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\r\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\r\n\r\n\t\t\t\tif ( normals ) {\r\n\r\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentCoordinate += 3;\r\n\r\n\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\r\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\r\n\r\n\t\t\t\t\tcurrentCoordinateUV += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnumVertices += 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\r\n\r\n\t\t\t// param p1, p2: Points in the circle arc.\r\n\t\t\t// p1 and p2 are in clockwise direction.\r\n\r\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\r\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\r\n\r\n\t\t\tlet angle = Math.PI;\r\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\r\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\r\n\r\n\t\t\tangle /= arcDivisions;\r\n\r\n\t\t\ttempV2_3.copy( p1 );\r\n\r\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\r\n\r\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\r\n\r\n\t\t\t\taddVertex( tempV2_3, u, v );\r\n\t\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\taddVertex( p2, u, v );\r\n\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentTriangles() {\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( currentPointL, u1, 1 );\r\n\t\t\taddVertex( currentPointR, u1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t// Optimized segment + bevel triangles\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\r\n\r\n\t\t\t// param center: End point of the path\r\n\t\t\t// param p1, p2: Left and right cap points\r\n\r\n\t\t\tswitch ( style.strokeLineCap ) {\r\n\r\n\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'square':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\tconst vl = vertices.length;\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'butt':\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t// Nothing to do here\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction removeDuplicatedPoints( points ) {\r\n\r\n\t\t\t// Creates a new array if necessary with duplicated points removed.\r\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\r\n\r\n\t\t\tlet dupPoints = false;\r\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\r\n\r\n\t\t\t\t\tdupPoints = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! dupPoints ) return points;\r\n\r\n\t\t\tconst newPoints = [];\r\n\t\t\tnewPoints.push( points[ 0 ] );\r\n\r\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\r\n\r\n\t\t\t\t\tnewPoints.push( points[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\r\n\r\n\t\t\treturn newPoints;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport { SVGLoader };\r\n"],
  "mappings": "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",
  "names": ["node", "data", "i", "current", "currentTransform", "scanlineMinX", "scanlineMaxX", "p", "joinIsOnLeftSide", "innerSideModified", "points"]
}
